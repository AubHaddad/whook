[//]: # ( )
[//]: # (This file is automatically generated by the `jsarch`)
[//]: # (module. Do not change it elsewhere, changes would)
[//]: # (be overriden.)
[//]: # ( )
# Architecture Notes



## A Whook baked API

This API server uses the Whook engine. Thoses architecture
 notes will help you to master its features.

You can see a view of the full architecture document
 by running `npm run architecture` and opening the generated
 `ARCHITECTURE.md` file.

[See in context](./src/index.ts#L13-L20)



### The main file

Per convention a Whook server main file must exports
 the following 3 functions to be composable.

[See in context](./src/index.ts#L22-L26)



#### runServer

The `runServer` function is intended to run the server
 and may be proxied as is, except in some e2e test cases
 where it can be useful to put mocks in (see
 [the E2E tests](./index.test.ts) coming with this project
 for a real world example).

[See in context](./src/index.ts#L28-L35)



#### prepareServer

The `prepareServer` function is intended to prepare the server
 environment. It relies on the main environment but will be
 used only by the server, not the commands or build scripts.

[See in context](./src/index.ts#L54-L59)



##### server wrappers

Add here any logic bound to the server only
 For example, here we add a Swagger UI page for
 development purpose.

[See in context](./src/index.ts#L64-L69)



#### prepareEnvironment

The `prepareEnvironment` one is intended to prepare the server environment

[See in context](./src/index.ts#L75-L78)



##### Autoloader

You can register any service/handler required to bootstrap
 the server env here manually, see Knifecycle for more infos
 https://github.com/nfroidure/knifecycle

OR, like in this example, use the Whook `$autoload` service
 that looks for handlers, configs and services for you in their
 respective folders. Of course, you can also write your own
 autoloader by creating a service with the same signature
 (see https://github.com/nfroidure/whook/blob/master/packages/whook/src/services/_autoload.ts).

[See in context](./src/index.ts#L98-L109)



##### API definitions

This service loads the API definitions directly by
 looking at your `src/handlers` folder. You can
 release this behavior by removing this line.
 Though, it is not recommended to not use the
 Whook's black magic ;).

[See in context](./src/index.ts#L112-L119)



##### PROJECT_SRC

You have to declare the project main file directory
 to allow autoloading features to work with it either
 in development and production (files built in `dist/`).

[See in context](./src/index.ts#L122-L127)



##### TRANSACTIONS

The Whook HTTP Transaction service, maintains an internal
 hash that handles a list of the current running HTTP
 transactions.

This line allows the [`getDiagnostic`](./src/handlers/getDiagnostic.ts)
 handler to get access to it in order to return the
 current transactions.

Simply try it like that:
```sh
# start the server
PORT=8080 npm run dev &
SRV_PID=$!;
sleep 3;

# Run an delayed handler
curl -X 'GET' 'http://localhost:8080/v8/delay?duration=3000' &

# get diagnostic data (you will see the 2 running handlers displayed)
curl -X 'GET' 'http://localhost:8080/v8/openAPI' \
 -H 'accept: application/json' -H 'Authorization: Fake admin|1|1';

echo "wait $SRV_PID";
sleep 1 && kill -s SIGTERM "$SRV_PID" &
wait "$SRV_PID";
```

[See in context](./src/index.ts#L130-L158)



##### WHOOK_PLUGINS

Plugins allows you to add simple features to the Whook's core,
 to add some, just add the plugin module name here.

You can also avoid Whook defaults by leaving it empty.

[See in context](./src/index.ts#L161-L167)



## Configuration

Configuration is done for each environement in the
 `src/config/${NODE_ENV}/config.ts` files.

The `src/config/common/config.ts` one allows to add common
 configurations for all environements.

[See in context](./src/config/common/config.ts#L12-L19)



### Typings

The configuration is typed so that you are sure you cannot
 produce a bad configuration for your API.

[See in context](./src/config/common/config.ts#L26-L30)



### Exporting

Each configuration file then create a configuration object
 and export it for the configuration service to load it.

See the [Whook Config Service](https://github.com/nfroidure/whook/blob/7dce55291a81628a0e95a07ce1e978a276b99578/packages/whook/src/services/CONFIGS.ts#L56).

[See in context](./src/config/common/config.ts#L48-L54)



### Overriding

Finally the configuration file for a given environnment
 may reuse or override the custom configuration file
 like here for the development configuration.

[See in context](./src/config/development/config.ts#L4-L9)



## API

Whook is all about APIs.

The API service defined here is where you put
 your handlers altogether to build the final API.

[See in context](./src/services/API.ts#L28-L33)



### Definition

This is how to declare a new route for your API.
 The syntax is pure [Open API](https://www.openapis.org/),
 the types are automatically generated with the `npm run watch`
 command.

For it to work, you have to export the definition, like
 here, to make it available for the API service, responsible
 for gathering all API route definitions.

[See in context](./src/handlers/getDelay.ts#L36-L46)



#### Operation ID

The name provided as the Open API `operationId` here
must map the handler name to link the definition
to it (here `getDelay`).

[See in context](./src/handlers/getDelay.ts#L51-L56)



#### Reusable parameters

This is how to declare a reusable API parameter
 to avoid having to write it several times and
 lower your final Open API file weight.

[See in context](./src/handlers/getDelay.ts#L15-L20)



##### Usage

To use reusable parameters, you must refer to it
 instead of writing it inline.

[See in context](./src/handlers/getDelay.ts#L61-L65)



#### Reusable schemas

This is how to declare a reusable API schema
 to avoid having to write it several times and
 lower your final Open API file weight.

[See in context](./src/handlers/putEcho.ts#L7-L12)



##### Usage

To use reusable schemas, you must refer to it
 instead of writing it inline.

You can use it in request/response bodies,
 inside parameters or even inside other
 schemas as per the OpenAPI specification.

[See in context](./src/handlers/putEcho.ts#L38-L46)



##### Typings

Schemas are converted to types so that
 TypeScript warns you when you don't output
 the expected data.

[See in context](./src/handlers/putEcho.ts#L90-L95)



### Implementation

The handler implementation is here, you can notice
 the Input/Ouput types that were automatically generated
 to help you keep definitions and code in sync.

Handlers implementations take dependencies as the first
 argument and parameters in the second.

Dependencies are injected by Whook on-demand based
 on their name.

Parameters are cleaned up and checked by Whook so
 that you just have to use the values according
 to the API contract you set in the handler's
 Open API definition above.

[See in context](./src/handlers/getDelay.ts#L78-L94)



#### Response

The handler's response are simple JSON serializable
 objects with a `status` and optional `body` and
 `headers` properties.

[See in context](./src/handlers/getDelay.ts#L105-L110)



#### Exportation

Here we simply tag the handler function as
 an handler Whook's will be able to use.

There is some magic here with the use of
 dependency injection with `Knifecycle`.

You can read more about it
 [here](https://github.com/nfroidure/knifecycle).

[See in context](./src/handlers/getDelay.ts#L116-L126)



#### Typings

Here we export a custom handler definition type in order
 to allow using the various plugins installed that deal
 with the handlers.

[See in context](./src/config/common/config.ts#L38-L43)



### Plugins

You can apply transformations to your API like
 here for CORS support (OPTIONS method handling).

[See in context](./src/services/API.ts#L85-L89)



#### Custom transformations

The API definition is a JSON serializable object, you
 can then reshape it the way you want. Here, we set a
 fake auth mecanism to help in development environment.

[See in context](./src/services/API.ts#L93-L98)



### Examples

The default Whook project contains a few sample
 handlers to help you grasp its principles.

You can keep some or just delete them and create
 yours with `npm run whook-dev -- create`.

[See in context](./src/handlers/getDelay.ts#L6-L13)



#### getDiagnostic

Here is a simple handler that just proxy the `TRANSACTIONS`
 service which contains the currently pending transactions.

[See in context](./src/handlers/getDiagnostic.ts#L4-L8)



#### getParameters

Here is a simple handler that just proxy the `TRANSACTIONS`
 service which contains the currently pending transactions.

[See in context](./src/handlers/getParameters.ts#L37-L41)



#### getTime

Returns the server time.

[See in context](./src/handlers/getTime.ts#L21-L24)



#### putEcho

Simply outputs its input.

[See in context](./src/handlers/putEcho.ts#L27-L30)



### Testing

Since the handlers do not need to deal with
 input/ouput validity, you can just write
 tests for the business logic.

[See in context](./src/handlers/getDelay.test.ts#L3-L8)



#### Services stubs

First you need to write stubs for services,
 pass it to the handler initializer and
 eventually mock their return values.

[See in context](./src/handlers/getDelay.test.ts#L10-L15)



#### Handler initialization

To get the testable handler, you first need to
 initialize it by providing mock services.

[See in context](./src/handlers/getDelay.test.ts#L29-L33)



#### Handler run

Then run the handler and get the response.
 Here, we snapshot the response and the
 services mock calls to ensure it do not
 changes unexpectedly.

 This is the force of Whook's serializable
  responses. It embed only the data structure,
  no method or other OOP noisy things.

[See in context](./src/handlers/getDelay.test.ts#L38-L48)



## Serving the Open API

Whook provides a handler to serve the final Open API
 definition.

We could use the `WHOOK_PLUGINS` service to get the
 handlers from plugins instead of proxying here, but
 we want to ensure the endpoint is reachable with
 a token too.

The fact that definitions are simple objects make them
 reusable and transformable easily. We could simply
 add new parameters or change the schema of the
 default definition of this endpoint.

[See in context](./src/handlers/getOpenAPI.ts#L6-L20)



## Services

Whook is shipped with a lots of services aimed to
 ease your life.

Handlers, services, commands can use services for their
 own needs. In fact handlers are services too so that
 you can reuse an handler inside another (for example to
 create a bulk API endpoint and run each handlers into it).

Whook's service can come from:
- the Whook's base environment
- the plugins services (found in the `@whook/{plugin}/src/services` folder)
- the project services (in the `src/services` folder)

[See in context](./src/index.ts#L82-L95)



### authentication

A fake authentication service you can use as a base
 authentication service.

[See in context](./src/services/authentication.ts#L22-L26)



### filterAPITags

Small tweak to be able to run only parts of the API
 by filtering endpoints via their tags. This makes of
 this example an anylith (a monolith that can split
 at will into micro-services).

For example, to create a server with only `system` and
 `example` tagged endpoints, juste do this:
```sh
FILTER_API_TAGS=system,example npm start
```

[See in context](./src/services/FILTER_API_TAGS.ts#L8-L20)



### jwtToken

A JWT token issuer service. Here, we simply reuse
 an external project and rename it by the way.

[See in context](./src/services/jwtToken.ts#L6-L10)



### MECHANISMS

A service aimed to provide implementations for the
 various supported auth mechanisms.

[See in context](./src/services/MECHANISMS.ts#L40-L44)



### QUERY_PARSER

Thanks to the DI system, you can easily customize
 Whook building blocks to match your flavor. Here,
 we override the default query parser behavior to
 be less strict than the `strict-qs` module
 set up per default.

You can navigate through the Whook's sources to
 get the overall list of its services. Another
 way is to run the server with the `DEBUG=knifecycle`
 environment variable to see what happens under the
 hood, in the DI system.

[See in context](./src/services/QUERY_PARSER.ts#L6-L19)



### WRAPPERS

Wrappers are allowing you to override every
 handlers of your API with specific behaviors,
 here we add CORS and HTTP authorization support
 to all the handlers defined in the API.

[See in context](./src/services/WRAPPERS.ts#L9-L15)



## Commands

We consider to be a good practice to bind the commands
 you write to your API code. The `src/commands` folder
 allows you to write commands in a similar way to handlers.

It leverages the dependency injection features of Whook
 and has helpers for parsing the input parameters.

You can list every available commands by running:
```sh
npm run whook-dev -- ls
```

Commands are a simple way to write utility scripts that leverage
 your application setup. It allows to simply inject services
 without worrying about their initialization.

[See in context](./src/commands/printEnv.ts#L7-L24)



### Definition

To define a command, just write its definition
 and export it to make it available to Whook's
 command loader.

[See in context](./src/commands/printEnv.ts#L26-L31)



### Implementation

To implement a command, just write a function that takes
 injected services as a first argument and return the
 command as an asynchronous function.

[See in context](./src/commands/printEnv.ts#L48-L53)



#### Injecting handlers

A good thing is that you can reuse any handler into
 your commands by simply injecting it by name.

[See in context](./src/commands/generateOpenAPISchema.ts#L39-L43)



### Examples

Whook's default project comes with a few sample commands.

[See in context](./src/commands/generateOpenAPITypes.ts#L6-L9)



#### Typings generator

This command allows you to generate the API types that
 helps you to write your handler in a clean and safe
 manner.

[See in context](./src/commands/generateOpenAPITypes.ts#L11-L16)



#### Open API generator

Here, we reuse the Open API handler to generate the
 definition of the API right inside a CLI command.

[See in context](./src/commands/generateOpenAPISchema.ts#L8-L12)



### Testing

In such a hard life, Whook's make it simple to
 also test your commands.

[See in context](./src/commands/generateOpenAPISchema.test.ts#L5-L9)

